### Аксиомы о каналах в Go

#### Общие аксиомы о каналах
1. **Отправка в nil-канал блокирует навсегда.**  
   Если канал равен `nil`, операция отправки (`ch <- value`) блокирует выполнение горутины навсегда.

2. **Получение из nil-канала блокирует навсегда.**  
   Если канал равен `nil`, операция получения (`<-ch`) блокирует выполнение горутины навсегда.

3. **Отправка в закрытый канал вызывает панику.**  
   Если канал закрыт (с помощью `close(ch)`), попытка отправить данные в него (`ch <- value`) вызовет `panic`.

4. **Получение из закрытого канала возвращает zero value немедленно.**  
   Если канал закрыт, операция получения (`<-ch`) немедленно возвращает zero value для типа данных канала, а второй возвращаемый параметр (`ok`) будет `false` (например, `value, ok := <-ch`).

#### Аксиомы о небуферизованных каналах
Небуферизованные каналы создаются с помощью `make(chan T)` и не имеют внутренней емкости (буфера).

5. **Чтение из небуферизованного канала блокирует до прихода писателя.**  
   Операция получения (`<-ch`) из небуферизованного канала блокирует горутину, пока другая горутина не отправит данные в этот канал (`ch <- value`).

6. **Запись в небуферизованный канал блокирует до прихода читателя.**  
   Операция отправки (`ch <- value`) в небуферизованный канал блокирует горутину, пока другая горутина не выполнит операцию получения (`<-ch`).

7. **Закрытие небуферизованного канала завершается успешно.**  
   Операция `close(ch)` на небуферизованном канале выполняется без ошибок, после чего дальнейшие операции чтения возвращают zero value, а отправка вызывает панику.

#### Аксиомы о буферизованных каналах
Буферизованные каналы создаются с помощью `make(chan T, capacity)` и имеют внутренний буфер фиксированного размера.

8. **Чтение из буферизованного канала с данными возвращает значение немедленно.**  
   Если в буферизованном канале есть данные (канал частично заполнен), операция получения (`<-ch`) возвращает следующее значение из буфера без блокировки.

9. **Чтение из пустого буферизованного канала блокирует до прихода писателя.**  
   Если буферизованный канал пуст (нет данных в буфере), операция получения (`<-ch`) блокирует горутину, пока другая горутина не отправит данные в канал (`ch <- value`).

10. **Запись в буферизованный канал с свободным местом выполняется немедленно.**  
    Если в буферизованном канале есть свободное место (буфер не полон), операция отправки (`ch <- value`) добавляет данные в буфер без блокировки.

11. **Запись в полный буферизованный канал блокирует до прихода читателя.**  
    Если буферизованный канал полон (буфер заполнен до предела), операция отправки (`ch <- value`) блокирует горутину, пока другая горутина не выполнит операцию получения (`<-ch`), освободив место в буфере.

#### Аксиомы о каналах только для чтения или только для записи
Каналы только для чтения или только для записи создаются с помощью направленных типов, например, `<-chan T` (только чтение) или `chan<- T` (только запись).

12. **Запись в канал только для чтения вызывает ошибку компиляции.**  
    Попытка отправить данные (`ch <- value`) в канал, объявленный как `<-chan T`, приведет к ошибке на этапе компиляции.

13. **Чтение из канала только для записи вызывает ошибку компиляции.**  
    Попытка получить данные (`<-ch`) из канала, объявленного как `chan<- T`, приведет к ошибке на этапе компиляции.

---

### Дополнительные пояснения
- **Zero value**: Это значение по умолчанию для типа данных канала. Например, для `chan int` zero value — это `0`, для `chan string` — пустая строка `""`, для `chan *T` — `nil`.
- **Panic**: В Go `panic` — это аварийное завершение программы, которое можно перехватить с помощью `recover`, но обычно это означает ошибку, которую нужно исправить в коде.
- **Блокировка**: Когда операция "блокирует", это означает, что горутина приостанавливается до выполнения определенного условия (например, прихода читателя или писателя). Go runtime эффективно управляет такими блокировками, не тратя ресурсы процессора.