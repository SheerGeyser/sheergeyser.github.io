{
  "title": "Квиз по основам Go",
  "questions": [
    {
      "question": "Как каналы устроены в Go?",
      "answers": [
        "Как очереди с фиксированной длиной и синхронизацией",
        "Как динамические массивы с автоматическим расширением",
        "Как мапы с доступом по ключу",
        "Как структуры с методами чтения и записи"
      ],
      "correctAnswerId": 0,
      "explanation": "Каналы в Go — это синхронизированные очереди, которые используются для обмена данными между горутинами. Они могут быть буферизированными или небуферизированными."
    },
    {
      "question": "Что такое горутины?",
      "answers": [
        "Легковесные потоки, управляемые runtime Go",
        "Системные потоки, управляемые ОС",
        "Асинхронные функции, работающие в одном потоке",
        "Методы для синхронизации каналов"
      ],
      "correctAnswerId": 0,
      "explanation": "Горутины — это легковесные потоки, управляемые планировщиком Go (runtime), а не операционной системой. Они позволяют выполнять конкурентные задачи."
    },
    {
      "question": "Что такое интерфейсы в Go?",
      "answers": [
        "Набор методов, которые тип должен реализовать",
        "Классы с абстрактными методами",
        "Структуры для инкапсуляции данных",
        "Функции для работы с мапами"
      ],
      "correctAnswerId": 0,
      "explanation": "Интерфейсы в Go — это набор методов, которые тип должен реализовать, чтобы соответствовать интерфейсу. Это ключевая часть утиной типизации."
    },
    {
      "question": "В чем разница между слайсами и массивами в Go?",
      "answers": [
        "Слайсы фиксированной длины, а массивы динамические",
        "Слайсы динамические, а массивы фиксированной длины",
        "Слайсы передаются по значению, а массивы по ссылке",
        "Слайсы не содержат указатель, а массивы содержат"
      ],
      "correctAnswerId": 1,
      "explanation": "Массивы имеют фиксированную длину, а слайсы — это динамические обертки над массивами, которые могут изменять размер."
    },
    {
      "question": "Как работает `map` в Go?",
      "answers": [
        "Как массив с индексами в виде ключей",
        "Как хэш-таблица с парами ключ-значение",
        "Как слайс с упорядоченными элементами",
        "Как очередь с доступом по ключу"
      ],
      "correctAnswerId": 1,
      "explanation": "Мапа в Go реализована как хэш-таблица, где ключи хэшируются для быстрого доступа к значениям."
    },
    {
      "question": "Как строки работают в Go внутри?",
      "answers": [
        "Как изменяемые массивы байтов",
        "Как неизменяемые слайсы байтов",
        "Как динамические слайсы символов",
        "Как мапы с индексами символов"
      ],
      "correctAnswerId": 1,
      "explanation": "Строки в Go — это неизменяемые слайсы байтов, которые обычно представляют UTF-8 кодировку."
    },
    {
      "question": "Как устроены контексты в Go?",
      "answers": [
        "Как мапы для хранения данных",
        "Как структуры для управления временем жизни и отменой операций",
        "Как каналы для передачи сигналов",
        "Как слайсы для передачи значений"
      ],
      "correctAnswerId": 1,
      "explanation": "Контексты (`context`) в Go используются для управления временем жизни операций, отмены и передачи значений между горутинами."
    },
    {
      "question": "Как слайсы работают в Go?",
      "answers": [
        "Как указатели на фиксированные массивы",
        "Как структуры с указателем на массив, длиной и емкостью",
        "Как мапы с индексами",
        "Как неизменяемые списки"
      ],
      "correctAnswerId": 1,
      "explanation": "Слайс — это структура с тремя полями: указатель на базовый массив, длина (`len`) и емкость (`cap`), что позволяет ему быть динамическим."
    },
    {
      "question": "Зачем нужны транзакции?",
      "answers": [
        "Для управления потоками в ОС",
        "Для обеспечения согласованности данных в БД",
        "Для синхронизации каналов",
        "Для кэширования запросов"
      ],
      "correctAnswerId": 1,
      "explanation": "Транзакции в базах данных нужны для обеспечения согласованности данных (свойства ACID), особенно при параллельных операциях."
    },
    {
      "question": "В чем разница между процессом и потоком в рамках операционной системы?",
      "answers": [
        "Процесс — это поток, а поток — это процесс",
        "Процесс — это независимая программа, а поток — часть процесса",
        "Процесс управляется runtime, а поток — ОС",
        "Процесс легче, чем поток"
      ],
      "correctAnswerId": 1,
      "explanation": "Процесс — это независимая программа с собственной памятью, а поток — это единица выполнения внутри процесса, разделяющая его память."
    },
    {
      "question": "Какие типы каналов существуют в Go?",
      "answers": [
        "Однонаправленные и двунаправленные",
        "Буферизированные и небуферизированные",
        "Синхронные и асинхронные",
        "Прямые и обратные"
      ],
      "correctAnswerId": 1,
      "explanation": "Каналы в Go бывают буферизированные (с фиксированной емкостью) и небуферизированные (синхронные). Также есть однонаправленные каналы, но это другой аспект."
    },
    {
      "question": "Как работает конструкция `select` в Go?",
      "answers": [
        "Как цикл для перебора каналов",
        "Как блокировка для мап",
        "Как конструкция для выбора первого доступного канала",
        "Как функция для создания каналов"
      ],
      "correctAnswerId": 2,
      "explanation": "`select` позволяет выбрать первый доступный канал для чтения или записи, либо выполнить `default`, если ни один канал не готов."
    },
    {
      "question": "В чем разница между TCP и UDP?",
      "answers": [
        "TCP быстрее, а UDP надежнее",
        "TCP обеспечивает надежность, а UDP — скорость",
        "TCP используется для потоков, а UDP для процессов",
        "TCP не поддерживает пакеты, а UDP поддерживает"
      ],
      "correctAnswerId": 1,
      "explanation": "TCP обеспечивает надежность (подтверждение доставки, порядок пакетов), а UDP быстрее, но не гарантирует доставку."
    },
    {
      "question": "Что такое `WaitGroup` в Go?",
      "answers": [
        "Механизм для блокировки каналов",
        "Инструмент для ожидания завершения группы горутин",
        "Структура для управления мапами",
        "Функция для создания горутин"
      ],
      "correctAnswerId": 1,
      "explanation": "`sync.WaitGroup` используется для ожидания завершения группы горутин, с помощью методов `Add`, `Done` и `Wait`."
    },
    {
      "question": "Как ООП реализовано в Go?",
      "answers": [
        "Через классы и наследование",
        "Через структуры и интерфейсы",
        "Через мапы и каналы",
        "Через указатели и функции"
      ],
      "correctAnswerId": 1,
      "explanation": "Go не имеет классов, но реализует ООП через структуры (данные), методы и интерфейсы (полиморфизм). Наследование отсутствует, используется композиция."
    },
    {
      "question": "Зачем нужна конструкция `defer` в Go?",
      "answers": [
        "Для немедленного выполнения функции",
        "Для отложенного выполнения функции до конца области видимости",
        "Для создания горутин",
        "Для управления каналами"
      ],
      "correctAnswerId": 1,
      "explanation": "`defer` откладывает выполнение функции до завершения текущей функции, часто используется для освобождения ресурсов (например, закрытия файлов)."
    },
    {
      "question": "В чем разница между буферизированными и небуферизированными каналами?",
      "answers": [
        "Буферизированные каналы синхронные, а небуферизированные асинхронные",
        "Буферизированные имеют емкость, а небуферизированные синхронные",
        "Буферизированные не блокируют, а небуферизированные блокируют всегда",
        "Буферизированные быстрее, а небуферизированные медленнее"
      ],
      "correctAnswerId": 1,
      "explanation": "Буферизированные каналы имеют емкость и не блокируют, пока буфер не полон, а небуферизированные каналы синхронные (блокируют до чтения/записи)."
    },
    {
      "question": "Что такое `mutex` и какие они бывают в Go?",
      "answers": [
        "Механизм для создания каналов, бывают буферизированные и небуферизированные",
        "Инструмент для синхронизации, бывают `Mutex` и `RWMutex`",
        "Структура для управления слайсами, бывают `Read` и `Write`",
        "Функция для работы с мапами, бывают `Lock` и `Unlock`"
      ],
      "correctAnswerId": 1,
      "explanation": "`Mutex` — это механизм синхронизации. В Go есть `sync.Mutex` (для полной блокировки) и `sync.RWMutex` (для разделения чтения и записи)."
    },
    {
      "question": "Какие недостатки есть у Go?",
      "answers": [
        "Высокая производительность и строгая типизация",
        "Отсутствие дженериков (до Go 1.18), слабая поддержка ООП, сложный сборщик мусора",
        "Наличие каналов и горутин",
        "Слишком много встроенных типов данных"
      ],
      "correctAnswerId": 1,
      "explanation": "До Go 1.18 отсутствовали дженерики, ООП ограничено (нет наследования), а сборщик мусора может вызывать задержки."
    },
    {
      "question": "Какие индексы в базах данных знаешь?",
      "answers": [
        "B-дерево, хэш, полнотекстовый, пространственный",
        "Слайсовый, маповый, канальный",
        "Синхронный, асинхронный, буферизированный",
        "Линейный, бинарный, случайный"
      ],
      "correctAnswerId": 0,
      "explanation": "В БД используются индексы, такие как B-дерево (для диапазонов), хэш (для точных совпадений), полнотекстовый (для поиска текста) и пространственный (для геоданных)."
    },
    {
      "question": "Что такое `context` в Go?",
      "answers": [
        "Механизм для управления каналами",
        "Инструмент для управления временем жизни и отменой операций",
        "Структура для хранения слайсов",
        "Функция для создания мап"
      ],
      "correctAnswerId": 1,
      "explanation": "`context` используется для управления временем жизни операций, отмены и передачи значений между горутинами."
    },
    {
      "question": "Какие базы данных бывают?",
      "answers": [
        "Реляционные, NoSQL, графовые, временные ряды",
        "Канальные, маповые, слайсовые",
        "Синхронные, асинхронные, буферизированные",
        "Локальные, удаленные, облачные"
      ],
      "correctAnswerId": 0,
      "explanation": "Базы данных делятся на реляционные (SQL), NoSQL (ключ-значение, документные), графовые (для связей) и временные ряды (для временных данных)."
    },
    {
      "question": "В чем ключевое различие слайса от массива?",
      "answers": [
        "Слайс фиксированной длины, а массив динамический",
        "Слайс динамический, а массив фиксированной длины",
        "Слайс передается по ссылке, а массив по значению",
        "Слайс не поддерживает `append`, а массив поддерживает"
      ],
      "correctAnswerId": 1,
      "explanation": "Слайс — это динамическая структура, а массив имеет фиксированную длину, заданную при объявлении."
    },
    {
      "question": "Что будет, если попытаться писать в закрытый канал?",
      "answers": [
        "Канал автоматически откроется",
        "Произойдет паника",
        "Значение будет проигнорировано",
        "Канал станет буферизированным"
      ],
      "correctAnswerId": 1,
      "explanation": "Запись в закрытый канал вызывает панику: `panic: send on closed channel`."
    },
    {
      "question": "Что такое репликация в контексте баз данных?",
      "answers": [
        "Копирование данных между серверами для повышения доступности",
        "Создание индексов для ускорения запросов",
        "Разделение данных на шарды",
        "Синхронизация каналов между серверами"
      ],
      "correctAnswerId": 0,
      "explanation": "Репликация — это копирование данных на несколько серверов для повышения отказоустойчивости и доступности."
    },
    {
      "question": "В чем отличия HTTP/1.1 и HTTP/2?",
      "answers": [
        "HTTP/1.1 поддерживает мультиплексирование, а HTTP/2 нет",
        "HTTP/2 поддерживает мультиплексирование и сжатие заголовков, а HTTP/1.1 нет",
        "HTTP/1.1 быстрее, а HTTP/2 надежнее",
        "HTTP/2 не поддерживает текст, а HTTP/1.1 поддерживает"
      ],
      "correctAnswerId": 1,
      "explanation": "HTTP/2 добавляет мультиплексирование (много запросов в одном соединении), сжатие заголовков и двоичный протокол, в отличие от текстового HTTP/1.1."
    },
    {
      "question": "Какие бывают типы данных в Go?",
      "answers": [
        "Только примитивные: int, string, bool",
        "Примитивные (int, string, bool), составные (slice, map, struct), ссылочные (pointer, channel)",
        "Только составные: slice, map, channel",
        "Только ссылочные: pointer, interface, channel"
      ],
      "correctAnswerId": 1,
      "explanation": "Go имеет примитивные типы (int, string, bool), составные (slice, map, struct) и ссылочные (pointer, channel, interface)."
    },
    {
      "question": "Что такое гарбидж коллектор в Go?",
      "answers": [
        "Механизм для создания горутин",
        "Система для автоматического управления памятью",
        "Инструмент для управления каналами",
        "Функция для очистки мап"
      ],
      "correctAnswerId": 1,
      "explanation": "Гарбидж коллектор (GC) в Go автоматически освобождает память, которая больше не используется, используя алгоритм mark-and-sweep."
    },
    {
      "question": "Как устроены строки в Go?",
      "answers": [
        "Как изменяемые массивы символов",
        "Как неизменяемые слайсы байтов с UTF-8",
        "Как динамические списки символов",
        "Как мапы с индексами"
      ],
      "correctAnswerId": 1,
      "explanation": "Строки в Go — это неизменяемые слайсы байтов, обычно содержащие UTF-8 кодировку."
    },
    {
      "question": "Как устроены таблицы `map` в Go?",
      "answers": [
        "Как массивы с индексами",
        "Как хэш-таблицы с бакетами",
        "Как слайсы с парами ключ-значение",
        "Как каналы для хранения данных"
      ],
      "correctAnswerId": 1,
      "explanation": "Мапы в Go реализованы как хэш-таблицы, где ключи хэшируются и распределяются по бакетам для быстрого доступа."
    },
    {
      "question": "Что такое SOLID?",
      "answers": [
        "Набор принципов для работы с каналами",
        "Принципы объектно-ориентированного проектирования",
        "Алгоритм для работы с мапами",
        "Паттерн для управления горутинами"
      ],
      "correctAnswerId": 1,
      "explanation": "SOLID — это принципы ООП: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion."
    },
    {
      "question": "В чем разница между `WHERE` и `HAVING` в SQL?",
      "answers": [
        "WHERE фильтрует группы, а HAVING фильтрует строки",
        "WHERE фильтрует строки, а HAVING фильтрует группы после GROUP BY",
        "WHERE используется с JOIN, а HAVING с SELECT",
        "WHERE быстрее, а HAVING точнее"
      ],
      "correctAnswerId": 1,
      "explanation": "`WHERE` фильтрует строки до агрегации, а `HAVING` фильтрует группы после `GROUP BY`."
    },
    {
      "question": "Насколько увеличивается слайс при `append`, если превышена емкость?",
      "answers": [
        "На 1 элемент",
        "В 2 раза (примерно)",
        "В 1.5 раза",
        "На фиксированное количество байтов"
      ],
      "correctAnswerId": 1,
      "explanation": "При превышении емкости слайса Go увеличивает его емкость примерно в 2 раза (до Go 1.18 это было так, сейчас может зависеть от размера)."
    },
    {
      "question": "Какие основные структуры данных есть в Go?",
      "answers": [
        "Только массивы и мапы",
        "Массивы, слайсы, мапы, структуры",
        "Только каналы и горутины",
        "Списки, деревья, графы"
      ],
      "correctAnswerId": 1,
      "explanation": "Встроенные структуры данных в Go: массивы, слайсы, мапы и структуры. Остальное реализуется вручную."
    },
    {
      "question": "В чем разница между императивным и декларативным программированием?",
      "answers": [
        "Императивное описывает, что делать, декларативное — как",
        "Декларативное описывает, что делать, императивное — как",
        "Императивное быстрее, декларативное медленнее",
        "Декларативное для каналов, императивное для мап"
      ],
      "correctAnswerId": 1,
      "explanation": "Императивное программирование описывает шаги (как), а декларативное — желаемый результат (что)."
    },
    {
      "question": "Чем горутины отличаются от тредов?",
      "answers": [
        "Горутины управляются ОС, а треды — runtime",
        "Горутины легче и управляются runtime Go, а треды тяжелее и управляются ОС",
        "Горутины медленнее, а треды быстрее",
        "Горутины не поддерживают синхронизацию, а треды поддерживают"
      ],
      "correctAnswerId": 1,
      "explanation": "Горутины — легковесные (занимают мало памяти), управляются runtime Go, а треды — системные, управляются ОС и требуют больше ресурсов."
    },
    {
      "question": "Возможны ли случаи, когда перебор по слайсу быстрее, чем по мапе?",
      "answers": [
        "Нет, мапы всегда быстрее",
        "Да, если слайс маленький и данные линейны",
        "Да, если мапа не инициализирована",
        "Нет, слайсы не поддерживают перебор"
      ],
      "correctAnswerId": 1,
      "explanation": "Для маленьких объемов данных перебор по слайсу может быть быстрее из-за линейного доступа к памяти, в отличие от хэширования в мапе."
    },
    {
      "question": "Что такое шардинг?",
      "answers": [
        "Копирование данных между серверами",
        "Разделение данных на части для распределения нагрузки",
        "Создание индексов для ускорения запросов",
        "Синхронизация каналов"
      ],
      "correctAnswerId": 1,
      "explanation": "Шардинг — это разделение данных на части (шарды), которые распределяются по серверам для повышения производительности."
    },
    {
      "question": "Что такое утиная типизация в Go?",
      "answers": [
        "Система типов, где типы проверяются во время компиляции",
        "Принцип: если объект ведет себя как тип, он считается этим типом",
        "Метод для работы с мапами",
        "Механизм для создания каналов"
      ],
      "correctAnswerId": 1,
      "explanation": "Утиная типизация: 'Если что-то выглядит как утка и крякает как утка, то это утка.' В Go это реализуется через интерфейсы."
    },
    {
      "question": "Какие преимущества есть у Go?",
      "answers": [
        "Сложный синтаксис и медленная компиляция",
        "Простота, быстрая компиляция, встроенная конкурентность",
        "Наличие классов и наследования",
        "Автоматическое управление потоками ОС"
      ],
      "correctAnswerId": 1,
      "explanation": "Go ценится за простоту, быструю компиляцию, встроенную поддержку конкурентности (горутины, каналы) и строгую типизацию."
    },
    {
      "question": "Каково стандартное поведение в Go при передаче функции?",
      "answers": [
        "Все передается по ссылке",
        "Все передается по значению",
        "Слайсы передаются по ссылке, а массивы по значению",
        "Мапы передаются по значению, а структуры по ссылке"
      ],
      "correctAnswerId": 1,
      "explanation": "В Go все передается по значению, но для слайсов, мап и указателей копируется ссылка на данные."
    },
    {
      "question": "Как инкапсуляция осуществлена в Go?",
      "answers": [
        "Через классы и модификаторы доступа",
        "Через регистр имени: заглавные буквы — публичные, строчные — приватные",
        "Через указатели и методы",
        "Через мапы и каналы"
      ],
      "correctAnswerId": 1,
      "explanation": "В Go инкапсуляция реализована через регистр имени: заглавные буквы делают идентификатор публичным, строчные — приватным в пределах пакета."
    },
    {
      "question": "Что делает команда `kill` в Linux?",
      "answers": [
        "Создает новый процесс",
        "Отправляет сигнал процессу, часто для его завершения",
        "Очищает память системы",
        "Перезапускает процесс"
      ],
      "correctAnswerId": 1,
      "explanation": "`kill` отправляет сигнал процессу (по умолчанию SIGTERM для завершения), но может отправлять и другие сигналы (например, SIGKILL)."
    },
    {
      "question": "Как завершить много горутин?",
      "answers": [
        "Закрыть все каналы",
        "Использовать `sync.WaitGroup` или закрыть канал для сигнала",
        "Вызвать `runtime.GoroutineExit()`",
        "Перезапустить программу"
      ],
      "correctAnswerId": 1,
      "explanation": "Для завершения горутин можно использовать `sync.WaitGroup` для ожидания или закрыть канал, который они читают, как сигнал завершения."
    },
    {
      "question": "Как наследование осуществлено в Go?",
      "answers": [
        "Через ключевое слово `extends`",
        "Наследование отсутствует, используется композиция",
        "Через указатели на структуры",
        "Через мапы и интерфейсы"
      ],
      "correctAnswerId": 1,
      "explanation": "Go не поддерживает классическое наследование, вместо этого используется композиция (встраивание структур)."
    },
    {
      "question": "Что такое HTTP?",
      "answers": [
        "Протокол для шифрования данных",
        "Протокол для передачи гипертекста между клиентом и сервером",
        "Механизм для управления потоками",
        "Функция для работы с мапами"
      ],
      "correctAnswerId": 1,
      "explanation": "HTTP (HyperText Transfer Protocol) — это протокол для передачи гипертекста (например, веб-страниц) между клиентом и сервером."
    },
    {
      "question": "Что такое эвакуация в контексте Go?",
      "answers": [
        "Процесс копирования данных между мапами",
        "Перемещение объектов в памяти во время работы сборщика мусора",
        "Очистка каналов",
        "Передача данных между горутинами"
      ],
      "correctAnswerId": 1,
      "explanation": "Эвакуация (evacuation) — это процесс перемещения объектов в памяти во время работы GC, например, при уплотнении кучи."
    },
    {
      "question": "Что такое микросервисная архитектура?",
      "answers": [
        "Монолитное приложение с одним сервисом",
        "Архитектура, где приложение разбито на независимые сервисы",
        "Система для управления каналами",
        "Паттерн для работы с мапами"
      ],
      "correctAnswerId": 1,
      "explanation": "Микросервисная архитектура разбивает приложение на небольшие независимые сервисы, которые взаимодействуют через API."
    },
    {
      "question": "В чем отличия HTTP и HTTPS?",
      "answers": [
        "HTTP быстрее, а HTTPS надежнее",
        "HTTPS использует шифрование (SSL/TLS), а HTTP нет",
        "HTTP поддерживает мультиплексирование, а HTTPS нет",
        "HTTPS только для текста, а HTTP для бинарных данных"
      ],
      "correctAnswerId": 1,
      "explanation": "HTTPS — это HTTP с шифрованием через SSL/TLS, что обеспечивает безопасность передачи данных."
    },
    {
      "question": "Как полиморфизм осуществлен в Go?",
      "answers": [
        "Через классы и наследование",
        "Через интерфейсы и утиную типизацию",
        "Через мапы и каналы",
        "Через указатели и слайсы"
      ],
      "correctAnswerId": 1,
      "explanation": "Полиморфизм в Go реализуется через интерфейсы: тип, реализующий методы интерфейса, автоматически соответствует этому интерфейсу."
    },
    {
      "question": "Кто управляет горутинами в Go?",
      "answers": [
        "Операционная система",
        "Планировщик Go runtime",
        "Сборщик мусора",
        "Каналы"
      ],
      "correctAnswerId": 1,
      "explanation": "Горутинами управляет планировщик Go runtime, который распределяет их по потокам ОС."
    },
    {
      "question": "Как преобразовать строку в `int` и наоборот в Go?",
      "code": "package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    s := \"123\"\n    i, _ := strconv.Atoi(s)\n    s2 := strconv.Itoa(456)\n    fmt.Println(i, s2)\n}",
      "answers": [
        "Использовать `int(s)` и `string(i)`",
        "Использовать `strconv.Atoi` и `strconv.Itoa`",
        "Использовать `parseInt(s)` и `toString(i)`",
        "Использовать `s.toInt()` и `i.toString()`"
      ],
      "correctAnswerId": 1,
      "explanation": "Для преобразования строки в `int` используется `strconv.Atoi`, а для `int` в строку — `strconv.Itoa`. Вывод: `123 456`."
    },
    {
      "question": "Что такое обычный `int` в Go и какие есть нюансы его реализации?",
      "answers": [
        "Фиксированный 32-битный тип без нюансов",
        "Зависит от архитектуры: 32 бита на 32-битных системах, 64 бита на 64-битных",
        "Всегда 64-битный тип",
        "Зависит от размера строки"
      ],
      "correctAnswerId": 1,
      "explanation": "`int` в Go зависит от архитектуры: 32 бита на 32-битных системах и 64 бита на 64-битных. Это влияет на диапазон значений."
    },
    {
      "question": "Можно ли сделать `int(string)` и `string(int)` в Go?",
      "answers": [
        "Да, это встроенные функции",
        "Нет, нужно использовать `strconv`",
        "Да, но только для строк длиной 1",
        "Нет, это вызовет панику"
      ],
      "correctAnswerId": 1,
      "explanation": "В Go нет прямых функций `int(string)` и `string(int)`. Нужно использовать `strconv.Atoi` и `strconv.Itoa`."
    },
    {
      "question": "Сколько в памяти занимают `int32` и `int64` в Go?",
      "answers": [
        "4 байта и 8 байт",
        "8 байт и 16 байт",
        "2 байта и 4 байта",
        "Зависит от архитектуры"
      ],
      "correctAnswerId": 0,
      "explanation": "`int32` занимает 4 байта (32 бита), `int64` — 8 байт (64 бита), независимо от архитектуры."
    },
    {
      "question": "Какие предельные значения у `int32` и `int64`?",
      "answers": [
        "int32: -2^31 до 2^31-1, int64: -2^63 до 2^63-1",
        "int32: -2^32 до 2^32-1, int64: -2^64 до 2^64-1",
        "int32: 0 до 2^31, int64: 0 до 2^63",
        "int32: -2^16 до 2^16-1, int64: -2^32 до 2^32-1"
      ],
      "correctAnswerId": 0,
      "explanation": "Для `int32` диапазон: -2,147,483,648 до 2,147,483,647 (-2^31 до 2^31-1). Для `int64`: -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 (-2^63 до 2^63-1)."
    },
    {
      "question": "Какой результат получим, если разделить `int` на 0 и `float` на 0?",
      "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i int = 5\n    var f float64 = 5.0\n    fmt.Println(i / 0)\n    fmt.Println(f / 0)\n}",
      "answers": [
        "Для `int` — паника, для `float` — `+Inf`",
        "Для обоих — паника",
        "Для обоих — `+Inf`",
        "Для `int` — 0, для `float` — паника"
      ],
      "correctAnswerId": 0,
      "explanation": "Деление `int` на 0 вызовет ошибку компиляции или панику (`division by zero`). Деление `float` на 0 вернет `+Inf` или `-Inf`."
    },
    {
      "question": "Что такое паттерн Factory (Фабрика)?",
      "answers": [
        "Паттерн для создания одиночных объектов",
        "Паттерн для создания объектов без указания их конкретного типа",
        "Паттерн для управления каналами",
        "Паттерн для работы с мапами"
      ],
      "correctAnswerId": 1,
      "explanation": "Фабрика — это паттерн, который позволяет создавать объекты, скрывая детали их создания и возвращая их через общий интерфейс."
    },
    {
      "question": "В чем отличие `uint` от `int` в Go?",
      "answers": [
        "uint — знаковый, int — беззнаковый",
        "uint — беззнаковый, int — знаковый",
        "uint быстрее, int медленнее",
        "uint занимает больше памяти, чем int"
      ],
      "correctAnswerId": 1,
      "explanation": "`uint` — беззнаковый целый тип (только положительные числа), `int` — знаковый (может быть отрицательным)."
    },
    {
      "question": "Что такое паттерн Builder (Строитель)?",
      "answers": [
        "Паттерн для создания одиночного объекта",
        "Паттерн для пошагового создания сложных объектов",
        "Паттерн для управления горутинами",
        "Паттерн для работы со слайсами"
      ],
      "correctAnswerId": 1,
      "explanation": "Builder позволяет пошагово создавать сложные объекты, разделяя процесс создания и представление объекта."
    },
    {
      "question": "Что такое runtime (планировщик) в Go?",
      "answers": [
        "Библиотека для работы с каналами",
        "Система для управления горутинами, памятью и сборкой мусора",
        "Инструмент для управления мапами",
        "Функция для создания слайсов"
      ],
      "correctAnswerId": 1,
      "explanation": "Runtime в Go — это система, которая управляет горутинами, памятью, сборкой мусора и другими низкоуровневыми аспектами."
    },
    {
      "question": "Как устроен runtime в Go?",
      "answers": [
        "Как мапа для хранения горутин",
        "Как планировщик с моделью GMP (Goroutine, Machine, Processor)",
        "Как слайс для управления потоками",
        "Как канал для передачи данных"
      ],
      "correctAnswerId": 1,
      "explanation": "Runtime Go использует модель GMP: Goroutine (горутины), Machine (потоки ОС), Processor (логические процессоры для выполнения горутин)."
    },
    {
      "question": "Как эффективно склеивать строки в Go?",
      "answers": [
        "Использовать `s1 + s2` в цикле",
        "Использовать `strings.Builder`",
        "Использовать `fmt.Sprintf`",
        "Использовать `strings.Join` с одним элементом"
      ],
      "correctAnswerId": 1,
      "explanation": "`strings.Builder` — наиболее эффективный способ, так как минимизирует копирование памяти. `+` создает новую строку на каждой итерации."
    },
    {
      "question": "Какие есть нюансы при итерации по строке в Go?",
      "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    s := \"привет\"\n    for i, r := range s {\n        fmt.Printf(\"%d: %c\\n\", i, r)\n    }\n}",
      "answers": [
        "Итерация идет по байтам, а не по символам",
        "Итерация идет по рунам (символам), но индексы — это байтовые позиции",
        "Итерация идет по символам, а индексы — это их позиции",
        "Итерация невозможна"
      ],
      "correctAnswerId": 1,
      "explanation": "`range` итерирует по рунам (Unicode-символам), но индексы — это позиции в байтах. Например, для \"привет\" индексы будут 0, 2, 4... из-за UTF-8."
    },
    {
      "question": "Как определить количество символов в строке в Go?",
      "answers": [
        "Использовать `len(s)`",
        "Использовать `utf8.RuneCountInString(s)`",
        "Использовать `len([]rune(s))`",
        "Использовать `s.Count()`"
      ],
      "correctAnswerId": 1,
      "explanation": "`utf8.RuneCountInString(s)` или `len([]rune(s))` возвращают количество символов (рун). `len(s)` возвращает количество байт."
    },
    {
      "question": "Что будет, если сложить строки в Go?",
      "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    s1 := \"hello\"\n    s2 := \"world\"\n    fmt.Println(s1 + s2)\n}",
      "answers": [
        "Произойдет паника",
        "Создастся новая строка: `helloworld`",
        "Будет создан слайс: `[hello, world]`",
        "Ничего не произойдет"
      ],
      "correctAnswerId": 1,
      "explanation": "Оператор `+` для строк создает новую строку, объединяя их. Вывод: `helloworld`."
    },
    {
      "question": "Что такое GMP-паттерн в Go?",
      "answers": [
        "Паттерн для управления мапами",
        "Модель планировщика: Goroutine, Machine, Processor",
        "Паттерн для работы со слайсами",
        "Механизм для создания каналов"
      ],
      "correctAnswerId": 1,
      "explanation": "GMP — это модель планировщика Go: Goroutine (горутины), Machine (потоки ОС), Processor (логические процессоры)."
    },
    {
      "question": "Можно ли изменить определенный символ в строке в Go?",
      "answers": [
        "Да, с помощью `s[i] = 'a'`",
        "Нет, строки неизменяемы",
        "Да, но только через указатель",
        "Да, через функцию `strings.Replace`"
      ],
      "correctAnswerId": 1,
      "explanation": "Строки в Go неизменяемы. Для изменения нужно создать новую строку, например, преобразовав в слайс рун и обратно."
    },
    {
      "question": "Какие функции у `map` в Go поддерживаются?",
      "answers": [
        "len, append, delete",
        "len, delete, range",
        "append, range, remove",
        "size, insert, delete"
      ],
      "correctAnswerId": 1,
      "explanation": "Для мап поддерживаются: `len(m)` (количество элементов), `delete(m, key)` (удаление), `range` (итерация). `append` — это для слайсов."
    },
    {
      "question": "Что из себя представляет тип данных `string` в Go?",
      "answers": [
        "Изменяемый массив байтов",
        "Неизменяемый слайс байтов с UTF-8",
        "Список символов",
        "Мапа с индексами"
      ],
      "correctAnswerId": 1,
      "explanation": "`string` — это неизменяемый слайс байтов, обычно содержащий UTF-8 кодировку."
    },
    {
      "question": "Сколько весит число в байтах в Go?",
      "answers": [
        "Всегда 4 байта",
        "Зависит от типа: int32 — 4 байта, int64 — 8 байт",
        "Всегда 8 байт",
        "Зависит от архитектуры"
      ],
      "correctAnswerId": 1,
      "explanation": "Размер числа зависит от типа: `int32` — 4 байта, `int64` — 8 байт. `int` зависит от архитектуры (4 или 8 байт)."
    },
    {
      "question": "Как работает сборщик мусора в Go?",
      "answers": [
        "Как цикл для очистки каналов",
        "Как mark-and-sweep с трехцветной маркировкой",
        "Как функция для очистки слайсов",
        "Как мапа для хранения данных"
      ],
      "correctAnswerId": 1,
      "explanation": "Сборщик мусора в Go использует алгоритм mark-and-sweep с трехцветной маркировкой, работая параллельно с программой."
    },
    {
      "question": "Какой концепт конструкция `defer` помогает реализовывать?",
      "answers": [
        "Создание горутин",
        "Управление ресурсами (RAII-подобный подход)",
        "Синхронизацию каналов",
        "Итерацию по мапам"
      ],
      "correctAnswerId": 1,
      "explanation": "`defer` помогает реализовать RAII-подобный подход (Resource Acquisition Is Initialization), например, для закрытия файлов."
    },
    {
      "question": "Какой вес у пустой структуры в Go?",
      "code": "package main\n\nimport \"unsafe\"\n\nfunc main() {\n    type Empty struct{}\n    var e Empty\n    println(unsafe.Sizeof(e))\n}",
      "answers": [
        "8 байт",
        "0 байт",
        "1 байт",
        "4 байта"
      ],
      "correctAnswerId": 0,
      "explanation": "Пустая структура в Go занимает 0 байт, но из-за особенностей выделения памяти Go может выделять 1 байт для различия экземпляров."
    },
    {
      "question": "Сколько весит пустая строка в байтах в Go?",
      "code": "package main\n\nimport \"unsafe\"\n\nfunc main() {\n    s := \"\"\n    println(unsafe.Sizeof(s))\n}",
      "answers": [
        "0 байт",
        "8 байт",
        "16 байт",
        "1 байт"
      ],
      "correctAnswerId": 2,
      "explanation": "Строка в Go — это структура с указателем и длиной, поэтому даже пустая строка занимает 16 байт (на 64-битной системе): 8 байт на указатель и 8 на длину."
    },
    {
      "question": "Что будет в `map`, если не делать `make` или short assign?",
      "answers": [
        "Мапа будет пустой",
        "Мапа будет nil",
        "Произойдет паника",
        "Мапа автоматически инициализируется"
      ],
      "correctAnswerId": 1,
      "explanation": "Без `make` или `map literal` (например, `m := map[string]int{}`) мапа будет `nil`, и запись в нее вызовет панику."
    },
    {
      "question": "Какое свойство должно быть у ключа в `map`?",
      "answers": [
        "Ключ должен быть неизменяемым",
        "Ключ должен поддерживать сравнение (`==`)",
        "Ключ должен быть числовым",
        "Ключ должен быть строкой"
      ],
      "correctAnswerId": 1,
      "explanation": "Ключи в мапе должны быть сравниваемыми (поддерживать `==`), поэтому слайсы, мапы и функции не могут быть ключами."
    },
    {
      "question": "У ресивера имеется звездочка — что это значит?",
      "code": "package main\n\ntype Counter struct { value int }\n\nfunc (c *Counter) Inc() {\n    c.value++\n}",
      "answers": [
        "Ресивер передается по значению",
        "Ресивер передается по указателю",
        "Метод нельзя вызвать",
        "Ресивер неизменяемый"
      ],
      "correctAnswerId": 1,
      "explanation": "Звездочка (`*`) означает, что ресивер передается по указателю, что позволяет изменять оригинальную структуру."
    },
    {
      "question": "Как работает `append` в слайсе?",
      "answers": [
        "Добавляет элемент в начало слайса",
        "Добавляет элемент в конец слайса, увеличивая емкость при необходимости",
        "Создает новый слайс без изменения оригинала",
        "Добавляет элемент в середину слайса"
      ],
      "correctAnswerId": 1,
      "explanation": "`append` добавляет элемент в конец слайса и увеличивает емкость, если она превышена, создавая новый базовый массив."
    },
    {
      "question": "Что будет, если подставить переменную в массив?",
      "code": "package main\n\nfunc main() {\n    arr := [3]int{1, 2, 3}\n    arr[1] = 5\n}",
      "answers": [
        "Произойдет паника",
        "Элемент заменится: `[1, 5, 3]`",
        "Массив станет динамическим",
        "Ничего не произойдет"
      ],
      "correctAnswerId": 1,
      "explanation": "Массив позволяет заменить элемент по индексу. Итог: `[1, 5, 3]`."
    },
    {
      "question": "Будут ли мапы упорядоченными в Go?",
      "answers": [
        "Да, в порядке добавления",
        "Нет, мапы не упорядочены",
        "Да, в алфавитном порядке ключей",
        "Да, в порядке значений"
      ],
      "correctAnswerId": 1,
      "explanation": "Мапы в Go не упорядочены, и итерация по ним происходит в случайном порядке."
    },
    {
      "question": "Как правильно объявлять мапу в Go?",
      "answers": [
        "var m map[string]int = map[]",
        "m := make(map[string]int)",
        "var m = map[string]int()",
        "m := map[string]int.new()"
      ],
      "correctAnswerId": 1,
      "explanation": "Правильный способ: `m := make(map[string]int)` или `m := map[string]int{}`. Другие варианты синтаксически неверны."
    },
    {
      "question": "Как быстро можно найти элемент, если искать по индексу в слайсе и в мапе?",
      "answers": [
        "В слайсе быстрее, чем в мапе",
        "В мапе быстрее, чем в слайсе",
        "Одинаково быстро",
        "Зависит от типа данных"
      ],
      "correctAnswerId": 1,
      "explanation": "Поиск в мапе быстрее (O(1) в среднем), чем в слайсе (O(n)), так как мапа использует хэширование."
    },
    {
      "question": "Какие отличия у быстрого объявления и объявления через `var` в Go?",
      "answers": [
        "Быстрое объявление (`:=`) работает только в функциях, `var` — везде",
        "Быстрое объявление всегда быстрее",
        "Объявление через `var` нельзя использовать в функциях",
        "Никаких отличий"
      ],
      "correctAnswerId": 0,
      "explanation": "Быстрое объявление (`:=`) работает только внутри функций и автоматически определяет тип, а `var` можно использовать везде."
    },
    {
      "question": "Какая средняя сложность поиска по слайсу и по мапе?",
      "answers": [
        "Слайс: O(1), мапа: O(n)",
        "Слайс: O(n), мапа: O(1)",
        "Слайс: O(log n), мапа: O(n)",
        "Слайс: O(n), мапа: O(log n)"
      ],
      "correctAnswerId": 1,
      "explanation": "Поиск в слайсе — линейный (O(n)), в мапе — в среднем O(1) за счет хэширования."
    },
    {
      "question": "Как объявлять слайс в Go?",
      "answers": [
        "var s []int",
        "var s [int]",
        "var s []int = make([]int)",
        "var s []int = new([]int)"
      ],
      "correctAnswerId": 0,
      "explanation": "Слайс объявляется как `var s []int` (пустой слайс) или с инициализацией: `s := make([]int, 0)` или `s := []int{}`."
    },
    {
      "question": "Какие ключи могут быть в мапе в Go?",
      "answers": [
        "Только строки и числа",
        "Любые сравниваемые типы (кроме слайсов, мап, функций)",
        "Только указатели",
        "Только структуры"
      ],
      "correctAnswerId": 1,
      "explanation": "Ключи в мапе должны быть сравниваемыми (поддерживать `==`), поэтому слайсы, мапы и функции не могут быть ключами."
    },
    {
      "question": "Какие типы данных можно использовать в ключах мапы?",
      "answers": [
        "Только примитивные типы",
        "Все типы, кроме слайсов, мап и функций",
        "Только указатели и структуры",
        "Только строки"
      ],
      "correctAnswerId": 1,
      "explanation": "Ключи должны быть сравниваемыми, поэтому нельзя использовать слайсы, мапы и функции. Остальные типы (числа, строки, структуры) подходят."
    },
    {
      "question": "Как устроены горутины и сколько памяти они занимают в стеке?",
      "answers": [
        "Горутины — это системные потоки, занимают 1 МБ",
        "Горутины — легковесные, изначально занимают 2 КБ стека",
        "Горутины — это каналы, занимают 8 байт",
        "Горутины — это мапы, занимают 16 байт"
      ],
      "correctAnswerId": 1,
      "explanation": "Горутины — легковесные, управляются runtime Go. Изначально их стек — 2 КБ (с Go 1.4), но он может расти при необходимости."
    }
  ]
}
